import { useMutation, useQueryClient } from '@tanstack/react-query'
import { useContext } from 'react'
import { toast } from 'react-toastify'
import { produce } from 'immer'

import purchaseApi from 'src/apis/purchases.api'
import { purchasesStatus } from 'src/constant/purchase'
import { AppContext } from 'src/contexts/app.context'
import { Purchase } from 'src/types/purchases.type'
import reviewApi from 'src/apis/review.api'

export const useOptimisticAddToCart = () => {
  const queryClient = useQueryClient()
  const { setExtendedPurchases } = useContext(AppContext)

  return useMutation({
    mutationFn: purchaseApi.addToCart,
    onMutate: async (newItem: { product_id: string; buy_count: number }) => {
      // H·ªßy c√°c queries ƒëang ch·ªù ƒë·ªÉ tr√°nh override optimistic update
      await queryClient.cancelQueries({
        queryKey: ['purchases', { status: purchasesStatus.inCart }]
      })

      // Snapshot data hi·ªán t·∫°i ƒë·ªÉ rollback khi c·∫ßn
      const previousPurchases = queryClient.getQueryData(['purchases', { status: purchasesStatus.inCart }])

      // L·∫•y th√¥ng tin s·∫£n ph·∫©m t·ª´ cache (n·∫øu c√≥)
      const allProductsQueries = queryClient.getQueriesData({ queryKey: ['products'] })
      let productData = null

      // T√¨m s·∫£n ph·∫©m trong c√°c queries cache
      for (const [, data] of allProductsQueries) {
        if (data && typeof data === 'object' && 'data' in data) {
          const products = (data as any).data?.data?.products || []
          productData = products.find((p: any) => p._id === newItem.product_id)
          if (productData) break
        }
      }

      // N·∫øu kh√¥ng t√¨m th·∫•y trong cache, c·ªë g·∫Øng l·∫•y t·ª´ product detail query
      if (!productData) {
        const productDetailQueries = queryClient.getQueriesData({ queryKey: ['product'] })
        for (const [, data] of productDetailQueries) {
          if (data && typeof data === 'object' && 'data' in data) {
            const product = (data as any).data?.data
            if (product && product._id === newItem.product_id) {
              productData = product
              break
            }
          }
        }
      }

      if (productData) {
        // T·∫°o optimistic purchase object
        const optimisticPurchase: Purchase = {
          _id: `temp-${Date.now()}`,
          buy_count: newItem.buy_count,
          price: productData.price,
          price_before_discount: productData.price_before_discount,
          status: purchasesStatus.inCart,
          user: 'current-user', // placeholder
          product: productData,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }

        // C·∫≠p nh·∫≠t cache optimistically
        queryClient.setQueryData(['purchases', { status: purchasesStatus.inCart }], (old: any) => {
          if (!old) return old
          return {
            ...old,
            data: {
              ...old.data,
              data: [...(old.data?.data || []), optimisticPurchase]
            }
          }
        })

        // C·∫≠p nh·∫≠t context state optimistically
        setExtendedPurchases((prev) => [
          ...prev,
          {
            ...optimisticPurchase,
            disabled: false,
            isChecked: true // T·ª± ƒë·ªông check s·∫£n ph·∫©m m·ªõi th√™m
          }
        ])

        // Hi·ªÉn th·ªã feedback ngay l·∫≠p t·ª©c
        toast.success('üõí ƒê√£ th√™m v√†o gi·ªè h√†ng!', {
          autoClose: 1500,
          position: 'top-center'
        })
      }

      return { previousPurchases, optimisticPurchase: productData }
    },

    onError: (err, newItem, context) => {
      // Rollback khi c√≥ l·ªói
      if (context?.previousPurchases) {
        queryClient.setQueryData(['purchases', { status: purchasesStatus.inCart }], context.previousPurchases)
      }

      // Rollback context state
      if (context?.optimisticPurchase) {
        setExtendedPurchases((prev) => prev.filter((item) => !item._id.startsWith('temp-')))
      }

      // Hi·ªÉn th·ªã l·ªói v·ªõi option th·ª≠ l·∫°i
      toast.error('‚ùå Kh√¥ng th·ªÉ th√™m v√†o gi·ªè h√†ng', {
        autoClose: 3000,
        position: 'top-center'
      })

      console.error('Add to cart error:', err)
    },

    onSuccess: (data, variables, context) => {
      // Thay th·∫ø item t·∫°m th·ªùi b·∫±ng data th·∫≠t t·ª´ server
      const realPurchase = data.data.data

      queryClient.setQueryData(['purchases', { status: purchasesStatus.inCart }], (old: any) => {
        if (!old) return old
        return {
          ...old,
          data: {
            ...old.data,
            data: old.data?.data?.map((item: Purchase) => (item._id.startsWith('temp-') ? realPurchase : item)) || [
              realPurchase
            ]
          }
        }
      })

      // C·∫≠p nh·∫≠t context v·ªõi data th·∫≠t
      setExtendedPurchases((prev) =>
        prev.map((item) =>
          item._id.startsWith('temp-') ? { ...realPurchase, disabled: false, isChecked: true } : item
        )
      )
    },

    onSettled: () => {
      // ƒê·∫£m b·∫£o sync v·ªõi server
      queryClient.invalidateQueries({
        queryKey: ['purchases', { status: purchasesStatus.inCart }]
      })
    }
  })
}

export const useOptimisticUpdateQuantity = () => {
  const queryClient = useQueryClient()
  const { setExtendedPurchases } = useContext(AppContext)

  return useMutation({
    mutationFn: purchaseApi.updatePurchase,
    onMutate: async ({ product_id, buy_count }) => {
      // H·ªßy queries ƒëang ch·ªù
      await queryClient.cancelQueries({
        queryKey: ['purchases', { status: purchasesStatus.inCart }]
      })

      const previousData = queryClient.getQueryData(['purchases', { status: purchasesStatus.inCart }])

      // C·∫≠p nh·∫≠t cache optimistically
      queryClient.setQueryData(['purchases', { status: purchasesStatus.inCart }], (old: any) => {
        if (!old) return old
        return {
          ...old,
          data: {
            ...old.data,
            data:
              old.data?.data?.map((purchase: Purchase) =>
                purchase.product._id === product_id ? { ...purchase, buy_count } : purchase
              ) || []
          }
        }
      })

      // C·∫≠p nh·∫≠t context state optimistically
      setExtendedPurchases(
        produce((draft) => {
          const item = draft.find((p) => p.product._id === product_id)
          if (item) {
            item.buy_count = buy_count
            item.disabled = false // Kh√¥ng disable UI trong optimistic mode
          }
        })
      )

      return { previousData, product_id }
    },

    onError: (err, variables, context) => {
      // Rollback changes
      if (context?.previousData) {
        queryClient.setQueryData(['purchases', { status: purchasesStatus.inCart }], context.previousData)
      }

      // Rollback context state
      setExtendedPurchases(
        produce((draft) => {
          const item = draft.find((p) => p.product._id === context?.product_id)
          if (item && context?.previousData) {
            const originalItem = (context.previousData as any)?.data?.data?.find(
              (p: Purchase) => p.product._id === context.product_id
            )
            if (originalItem) {
              item.buy_count = originalItem.buy_count
              item.disabled = false
            }
          }
        })
      )

      toast.error('‚ùå Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng', {
        autoClose: 2000,
        position: 'top-center'
      })
    },

    onSuccess: (data, variables) => {
      // Update v·ªõi data t·ª´ server n·∫øu kh√°c v·ªõi optimistic update
      const updatedPurchase = data.data.data

      setExtendedPurchases(
        produce((draft) => {
          const item = draft.find((p) => p.product._id === variables.product_id)
          if (item) {
            item.buy_count = updatedPurchase.buy_count
            item.disabled = false
          }
        })
      )
    },

    onSettled: () => {
      // Sync v·ªõi server
      queryClient.invalidateQueries({
        queryKey: ['purchases', { status: purchasesStatus.inCart }]
      })
    }
  })
}

export const useOptimisticReviewLike = (productId: string) => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: reviewApi.toggleReviewLike,
    onMutate: async (reviewId: string) => {
      // H·ªßy c√°c queries ƒëang ch·ªù ƒë·ªÉ tr√°nh override optimistic update
      await queryClient.cancelQueries({
        queryKey: ['product-reviews', productId]
      })

      // Snapshot data hi·ªán t·∫°i ƒë·ªÉ rollback khi c·∫ßn
      const previousReviews = queryClient.getQueryData(['product-reviews', productId])

      // C·∫≠p nh·∫≠t cache optimistically
      queryClient.setQueryData(['product-reviews', productId], (old: any) => {
        if (!old) return old

        return {
          ...old,
          data: {
            ...old.data,
            data: {
              ...old.data.data,
              reviews: old.data.data.reviews.map((review: any) =>
                review._id === reviewId
                  ? {
                      ...review,
                      is_liked: !review.is_liked,
                      helpful_count: review.helpful_count + (review.is_liked ? -1 : 1)
                    }
                  : review
              )
            }
          }
        }
      })

      // Hi·ªÉn th·ªã feedback ngay l·∫≠p t·ª©c
      const isCurrentlyLiked = previousReviews
        ? (previousReviews as any).data?.data?.reviews?.find((r: any) => r._id === reviewId)?.is_liked
        : false

      toast.success(isCurrentlyLiked ? 'üíî ƒê√£ b·ªè th√≠ch ƒë√°nh gi√°' : '‚ù§Ô∏è ƒê√£ th√≠ch ƒë√°nh gi√°!', {
        autoClose: 1000,
        position: 'top-center'
      })

      return { previousReviews, reviewId }
    },

    onError: (err, reviewId, context) => {
      // Rollback khi c√≥ l·ªói
      if (context?.previousReviews) {
        queryClient.setQueryData(['product-reviews', productId], context.previousReviews)
      }

      // Hi·ªÉn th·ªã l·ªói
      toast.error('‚ùå Kh√¥ng th·ªÉ th·ª±c hi·ªán thao t√°c', {
        autoClose: 2000,
        position: 'top-center'
      })

      console.error('Review like error:', err)
    },

    onSuccess: (data, reviewId, context) => {
      // C·∫≠p nh·∫≠t v·ªõi data th·∫≠t t·ª´ server
      queryClient.setQueryData(['product-reviews', productId], (old: any) => {
        if (!old) return old

        return {
          ...old,
          data: {
            ...old.data,
            data: {
              ...old.data.data,
              reviews: old.data.data.reviews.map((review: any) =>
                review._id === reviewId
                  ? {
                      ...review,
                      is_liked: data.data.data.is_liked,
                      helpful_count: data.data.data.helpful_count
                    }
                  : review
              )
            }
          }
        }
      })
    },

    onSettled: () => {
      // ƒê·∫£m b·∫£o sync v·ªõi server
      queryClient.invalidateQueries({
        queryKey: ['product-reviews', productId]
      })
    }
  })
}

export const useOptimisticRemoveFromCart = () => {
  const queryClient = useQueryClient()
  const { setExtendedPurchases } = useContext(AppContext)

  return useMutation({
    mutationFn: purchaseApi.deletePurchase,
    onMutate: async (purchaseIds: string[]) => {
      // H·ªßy c√°c queries ƒëang ch·ªù
      await queryClient.cancelQueries({
        queryKey: ['purchases', { status: purchasesStatus.inCart }]
      })

      const previousData = queryClient.getQueryData(['purchases', { status: purchasesStatus.inCart }])

      // L∆∞u th√¥ng tin s·∫£n ph·∫©m b·ªã x√≥a ƒë·ªÉ c√≥ th·ªÉ undo
      const removedItems =
        (previousData as any)?.data?.data?.filter((purchase: Purchase) => purchaseIds.includes(purchase._id)) || []

      // C·∫≠p nh·∫≠t cache optimistically - x√≥a items ngay l·∫≠p t·ª©c
      queryClient.setQueryData(['purchases', { status: purchasesStatus.inCart }], (old: any) => {
        if (!old) return old
        return {
          ...old,
          data: {
            ...old.data,
            data: old.data.data.filter((purchase: Purchase) => !purchaseIds.includes(purchase._id))
          }
        }
      })

      // C·∫≠p nh·∫≠t context state optimistically
      setExtendedPurchases((prev) => prev.filter((item) => !purchaseIds.includes(item._id)))

      // Hi·ªÉn th·ªã th√¥ng b√°o v·ªõi option undo
      const isMultiple = purchaseIds.length > 1
      const undoToast = toast.success(
        `üóëÔ∏è ƒê√£ x√≥a ${isMultiple ? `${purchaseIds.length} s·∫£n ph·∫©m` : 's·∫£n ph·∫©m'} kh·ªèi gi·ªè h√†ng`,
        {
          autoClose: 5000,
          position: 'top-center',
          closeButton: false,
          hideProgressBar: false,
          onClick: () => {
            // Undo functionality
            if (previousData) {
              queryClient.setQueryData(['purchases', { status: purchasesStatus.inCart }], previousData)
              setExtendedPurchases((prev) => {
                const restoredItems = removedItems.map((item: Purchase) => ({
                  ...item,
                  disabled: false,
                  isChecked: false
                }))
                return [...prev, ...restoredItems]
              })
              toast.dismiss(undoToast)
              toast.info('‚Ü©Ô∏è ƒê√£ kh√¥i ph·ª•c s·∫£n ph·∫©m', {
                autoClose: 2000,
                position: 'top-center'
              })
            }
          }
        }
      )

      return { previousData, removedItems, undoToast }
    },

    onError: (err, purchaseIds, context) => {
      // Rollback khi c√≥ l·ªói
      if (context?.previousData) {
        queryClient.setQueryData(['purchases', { status: purchasesStatus.inCart }], context.previousData)

        // Kh√¥i ph·ª•c context state
        if (context.removedItems) {
          setExtendedPurchases((prev) => {
            const restoredItems = context.removedItems.map((item: Purchase) => ({
              ...item,
              disabled: false,
              isChecked: false
            }))
            return [...prev, ...restoredItems]
          })
        }
      }

      // Dismiss undo toast n·∫øu c√≥
      if (context?.undoToast) {
        toast.dismiss(context.undoToast)
      }

      // Hi·ªÉn th·ªã l·ªói
      toast.error('‚ùå Kh√¥ng th·ªÉ x√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng', {
        autoClose: 3000,
        position: 'top-center'
      })

      console.error('Remove from cart error:', err)
    },

    onSuccess: (data, purchaseIds, context) => {
      // Dismiss undo toast khi th√†nh c√¥ng
      if (context?.undoToast) {
        toast.dismiss(context.undoToast)
      }

      // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng cu·ªëi c√πng
      const isMultiple = purchaseIds.length > 1
      toast.success(`‚úÖ ƒê√£ x√≥a ${isMultiple ? `${purchaseIds.length} s·∫£n ph·∫©m` : 's·∫£n ph·∫©m'} th√†nh c√¥ng`, {
        autoClose: 2000,
        position: 'top-center'
      })
    },

    onSettled: () => {
      // Sync v·ªõi server
      queryClient.invalidateQueries({
        queryKey: ['purchases', { status: purchasesStatus.inCart }]
      })
    }
  })
}
