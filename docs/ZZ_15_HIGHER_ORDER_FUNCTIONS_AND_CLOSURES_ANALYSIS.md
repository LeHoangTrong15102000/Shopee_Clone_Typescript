# üöÄ Higher Order Functions & Closures trong Shopee Clone TypeScript

## üìñ M·ª•c L·ª•c

1. [Gi·ªõi thi·ªáu v·ªÅ Higher Order Functions](#gi·ªõi-thi·ªáu-v·ªÅ-higher-order-functions)
2. [Gi·ªõi thi·ªáu v·ªÅ Closures](#gi·ªõi-thi·ªáu-v·ªÅ-closures)
3. [Higher Order Functions trong d·ª± √°n](#higher-order-functions-trong-d·ª±-√°n)
4. [Closures trong d·ª± √°n](#closures-trong-d·ª±-√°n)
5. [React Hooks v√† Closures](#react-hooks-v√†-closures)
6. [Performance v√† Memory Management](#performance-v√†-memory-management)
7. [Best Practices](#best-practices)
8. [K·∫øt lu·∫≠n](#k·∫øt-lu·∫≠n)

---

## üéØ Gi·ªõi thi·ªáu v·ªÅ Higher Order Functions

### üìö **ƒê·ªãnh nghƒ©a**

**Higher Order Function (HOF)** l√† m·ªôt function c√≥ √≠t nh·∫•t m·ªôt trong nh·ªØng ƒë·∫∑c ƒëi·ªÉm sau:

1. **Nh·∫≠n m·ªôt ho·∫∑c nhi·ªÅu functions l√†m arguments**
2. **Return v·ªÅ m·ªôt function**

### üîç **T·∫°i sao HOF quan tr·ªçng?**

- ‚úÖ **Code Reusability**: T√°i s·ª≠ d·ª•ng logic
- ‚úÖ **Functional Programming**: L·∫≠p tr√¨nh h√†m
- ‚úÖ **Abstraction**: Tr·ª´u t∆∞·ª£ng h√≥a logic ph·ª©c t·∫°p
- ‚úÖ **Composition**: K·∫øt h·ª£p c√°c functions

---

## üîê Gi·ªõi thi·ªáu v·ªÅ Closures

### üìö **ƒê·ªãnh nghƒ©a**

**Closure** l√† m·ªôt function c√≥ th·ªÉ **truy c·∫≠p v√†o variables t·ª´ outer scope** ngay c·∫£ khi outer function ƒë√£ k·∫øt th√∫c th·ª±c thi.

### üß† **C√°ch ho·∫°t ƒë·ªông**

```javascript
function outerFunction(x) {
  // Outer scope variable
  return function innerFunction(y) {
    // Inner function c√≥ th·ªÉ truy c·∫≠p x t·ª´ outer scope
    return x + y
  }
}

const addFive = outerFunction(5) // x = 5 ƒë∆∞·ª£c "ƒë√≥ng g√≥i" trong closure
console.log(addFive(10)) // 15 - x v·∫´n ƒë∆∞·ª£c nh·ªõ!
```

---

## üõçÔ∏è Higher Order Functions trong d·ª± √°n

### 1. **Array Methods - Map, Filter, Reduce**

#### üìç **Trong ProductList.tsx**

```typescript
// src/pages/ProductList/ProductList.tsx (d√≤ng 82-86)
{productsData.data.data.products.map((product, index) => (
  <div className='col-span-1' key={product._id}>
    <Product product={product} />
  </div>
))}
```

**Ph√¢n t√≠ch:**

- `map()` l√† Higher Order Function
- Nh·∫≠n v√†o m·ªôt **callback function** `(product, index) => JSX`
- Return v·ªÅ array m·ªõi c·ªßa JSX elements

#### üìç **Trong Cart.tsx - Complex Data Processing**

```typescript
// src/pages/Cart/Cart.tsx (d√≤ng 83-87)
const checkedPurchases = useMemo(() => extendedPurchases.filter((purchase) => purchase.isChecked), [extendedPurchases])

// T√≠nh t·ªïng ti·ªÅn (d√≤ng 92-97)
const totalCheckedPurchasePrice = useMemo(
  () =>
    checkedPurchases.reduce((result, currentPurchase) => result + currentPurchase.price * currentPurchase.buy_count, 0),
  [checkedPurchases]
)

// T√≠nh ti·ªÅn ti·∫øt ki·ªám (d√≤ng 101-107)
const totalCheckedPurchaseSavingPrice = useMemo(
  () =>
    checkedPurchases.reduce(
      (result, currentPurchase) =>
        result + (currentPurchase.price_before_discount - currentPurchase.price) * currentPurchase.buy_count,
      0
    ),
  [checkedPurchases]
)
```

**Ph√¢n t√≠ch HOF:**

1. **`filter()`**: HOF nh·∫≠n callback `(purchase) => purchase.isChecked`
2. **`reduce()`**: HOF nh·∫≠n callback `(result, currentPurchase) => calculation`
3. **`useMemo()`**: HOF nh·∫≠n callback function ƒë·ªÉ memoize k·∫øt qu·∫£

#### üìç **Trong Home.tsx - Data Slicing**

```typescript
// src/pages/Home/Home.tsx
{categories.slice(0, 16).map((category) => (
  <CategoryCard key={category._id} category={category} />
))}

{featuredProducts.slice(0, 6).map((product) => (
  <ProductCard key={product._id} product={product} />
))}

{newProducts.slice(0, 12).map((product) => (
  <ProductCard key={product._id} product={product} />
))}
```

**Ph√¢n t√≠ch:**

- **`slice()`**: HOF method ƒë·ªÉ c·∫Øt array
- **`map()`**: HOF ƒë·ªÉ transform data

### 2. **Lodash Higher Order Functions**

#### üìç **omitBy trong useQueryConfig.tsx**

```typescript
// src/hooks/useQueryConfig.tsx (d√≤ng 13-25)
const queryConfig: QueryConfig = omitBy(
  {
    page: queryParams.page || '1',
    limit: queryParams.limit || '20',
    sort_by: queryParams.sort_by,
    exclude: queryParams.exclude,
    name: queryParams.name,
    order: queryParams.order,
    price_max: queryParams.price_max,
    price_min: queryParams.price_min,
    rating_filter: queryParams.rating_filter,
    category: queryParams.category
  },
  isUndefined // Predicate function
)
```

**Ph√¢n t√≠ch:**

- `omitBy()` l√† HOF t·ª´ Lodash
- Nh·∫≠n **predicate function** `isUndefined`
- Return object m·ªõi sau khi lo·∫°i b·ªè properties undefined

#### üìç **keyBy trong Cart.tsx**

```typescript
// src/pages/Cart/Cart.tsx (d√≤ng 114-115)
const extendedPurchasesObject = keyBy(prev, '_id')
// T∆∞∆°ng ƒë∆∞∆°ng v·ªõi:
// keyBy(array, iteratee) - iteratee c√≥ th·ªÉ l√† function ho·∫∑c property path
```

**Ph√¢n t√≠ch:**

- `keyBy()` l√† HOF t·ª´ Lodash
- C√≥ th·ªÉ nh·∫≠n function l√†m iteratee: `keyBy(array, item => item.id)`
- Ho·∫∑c property path: `keyBy(array, '_id')`

#### üìç **omit trong nhi·ªÅu components**

```typescript
// src/pages/Register/Register.tsx (d√≤ng 54)
const body = omit(data, ['confirm_password'])

// src/pages/User/pages/ChangePassword/ChangePassword.tsx (d√≤ng 42)
const res = await updateProfileMutation.mutateAsync(omit(data, ['confirm_password']))

// src/hooks/useSearchProducts.tsx (d√≤ng 35-36)
const config = queryConfig.order
  ? omit({ ...queryConfig, name: data.name }, ['order', 'sort_by'])
  : { ...queryConfig, name: data.name }
```

**Ph√¢n t√≠ch:**

- `omit()` l√† HOF utility function
- Lo·∫°i b·ªè specified properties t·ª´ object
- Return new object (immutable operation)

### 3. **Custom Higher Order Functions**

#### üìç **Event Handler Factories (Currying Pattern)**

```typescript
// src/pages/Cart/Cart.tsx (d√≤ng 148-152)
const handleChecked = (purchaseIndex: number) => (event: React.ChangeEvent<HTMLInputElement>) => {
  setExtendedPurchases(
    produce((draft) => {
      draft[purchaseIndex].isChecked = event.target.checked
    })
  )
}
```

**Ph√¢n t√≠ch Currying:**

- **Level 1**: `handleChecked(purchaseIndex)`
- **Level 2**: Return function `(event) => {...}`
- **Closure**: Inner function c√≥ th·ªÉ access `purchaseIndex`
- **Usage**: `handleChecked(index)` creates specific handler

#### üìç **More Currying Examples**

```typescript
// src/pages/Cart/Cart.tsx (d√≤ng 171-175)
const handleTypeQuantity = (purchaseIndex: number) => (value: number) => {
  setExtendedPurchases(
    produce((draft) => {
      draft[purchaseIndex].buy_count = value
    })
  )
}

// src/pages/Cart/Cart.tsx (d√≤ng 194-203)
const handleDelete = (purchaseIndex: number) => () => {
  const purchaseId = extendedPurchases[purchaseIndex]._id
  deletePurchasesMutation.mutate([purchaseId], {
    onSuccess: () => {
      toast.success('Xo√° s·∫£n ph·∫©m th√†nh c√¥ng!')
    }
  })
}
```

**T·∫°i sao s·ª≠ d·ª•ng Currying?**

- ‚úÖ **Partial Application**: Apply arguments t·ª´ng b∆∞·ªõc
- ‚úÖ **Event Handler Optimization**: T·∫°o stable references
- ‚úÖ **Code Reusability**: T√°i s·ª≠ d·ª•ng v·ªõi different parameters
- ‚úÖ **Better Performance**: Tr√°nh t·∫°o anonymous functions trong render

---

## üîê Closures trong d·ª± √°n

### 1. **useDebounce Hook - Classic Closure Example**

```typescript
// src/hooks/useDebounce.tsx
const useDebounce = (value: null | FormData['name'], delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value)

  useEffect(() => {
    // Closure: handler function c√≥ th·ªÉ access value v√† setDebouncedValue
    const handler = setTimeout(() => setDebouncedValue(value?.trim() as string), delay)

    // Cleanup closure: return function c√≥ th·ªÉ access handler
    return () => clearTimeout(handler)
  }, [value])

  return debouncedValue
}
```

**Ph√¢n t√≠ch Closure:**

1. **Outer scope**: `value`, `delay`, `setDebouncedValue`
2. **Inner functions**:
   - `setTimeout callback`: access `value`, `setDebouncedValue`
   - `cleanup function`: access `handler`
3. **Persistence**: Variables ƒë∆∞·ª£c "nh·ªõ" qua c√°c l·∫ßn re-render

### 2. **Event Handlers with Closure**

#### üìç **SearchSuggestions Component**

```typescript
// src/components/Header/SearchSuggestions/SearchSuggestions.tsx (d√≤ng 98-108)
const handleSelectSuggestion = useCallback(
  (suggestion: string) => {
    onSelectSuggestion(suggestion) // Closure: access prop function
    productApi.saveSearchHistory({ keyword: suggestion }).catch((error) => {
      console.warn('Kh√¥ng th·ªÉ l∆∞u l·ªãch s·ª≠ t√¨m ki·∫øm:', error)
    })
    onHide() // Closure: access prop function
  },
  [onSelectSuggestion, onHide] // Dependencies captured in closure
)

const handleImageError = useCallback(
  (event: React.SyntheticEvent<HTMLImageElement>, productId: string) => {
    const img = event.target as HTMLImageElement

    // Closure: access state variable
    if (!failedImages.has(productId)) {
      // Closure: access setState function
      setFailedImages((prev) => new Set(prev).add(productId))
      img.src = 'data:image/svg+xml;base64,...'
    }
  },
  [failedImages] // Closure dependency
)
```

**Closure Analysis:**

- **Captured variables**: `onSelectSuggestion`, `onHide`, `failedImages`, `setFailedImages`
- **useCallback**: Memoizes closures ƒë·ªÉ tr√°nh unnecessary re-renders
- **Dependencies**: Khi dependencies thay ƒë·ªïi, closure ƒë∆∞·ª£c t·∫°o l·∫°i

### 3. **Component State Closures**

#### üìç **ProductReviews Component**

```typescript
// src/components/ProductReviews/ProductReviews.tsx (d√≤ng 75-85)
const handleLike = (reviewId: string) => {
  likeMutation.mutate(reviewId, {
    onSuccess: () => {
      // Closure: access queryClient and productId from outer scope
      queryClient.invalidateQueries({ queryKey: ['product-reviews', productId] })
    },
    onError: () => {
      toast.error('C√≥ l·ªói x·∫£y ra khi th√≠ch ƒë√°nh gi√°')
    }
  })
}
```

### 4. **useMemo Closures**

#### üìç **Complex Calculations with Closure**

```typescript
// src/components/Header/SearchSuggestions/SearchSuggestions.tsx (d√≤ng 75-87)
const suggestions = useMemo(
  () =>
    suggestionsData?.data.data.suggestions ||
    (suggestionsError && debouncedSearchValue
      ? [
          `${debouncedSearchValue} samsung`, // Closure: access debouncedSearchValue
          `${debouncedSearchValue} iphone`,
          `${debouncedSearchValue} oppo`,
          `${debouncedSearchValue} xiaomi`
        ].filter((item) => item.trim() !== debouncedSearchValue) // Closure again
      : []),
  [suggestionsData, suggestionsError, debouncedSearchValue] // Dependencies
)

const products = useMemo(
  () =>
    suggestionsData?.data.data.products ||
    (suggestionsError && debouncedSearchValue
      ? mockProducts.filter((product) =>
          // Closure: access debouncedSearchValue in nested function
          product.name.toLowerCase().includes(debouncedSearchValue.toLowerCase())
        )
      : []),
  [suggestionsData, suggestionsError, debouncedSearchValue]
)
```

---

## ‚öõÔ∏è React Hooks v√† Closures

### 1. **useEffect Closures**

#### üìç **Component Lifecycle Management**

```typescript
// src/pages/Cart/Cart.tsx (d√≤ng 109-139)
useEffect(() => {
  setExtendedPurchases((prev) => {
    // Closure: access purchasesInCart, choosenPurchaseIdFromLocation
    const extendedPurchasesObject = keyBy(prev, '_id')

    return (
      purchasesInCart?.map((purchase) => {
        // Nested closure: access choosenPurchaseIdFromLocation
        const isChoosenPurchaseIdFromLocation = choosenPurchaseIdFromLocation === purchase._id
        return {
          ...purchase,
          disabled: false,
          isChecked: isChoosenPurchaseIdFromLocation || Boolean(extendedPurchasesObject[purchase._id]?.isChecked)
        }
      }) || []
    )
  })

  // Timer closure
  const handler = setTimeout(
    () =>
      // Closure: access navigate, pathname
      navigate(pathname, { state: null, replace: true }),
    500
  )

  // Cleanup closure
  return () => clearTimeout(handler)
}, [purchasesInCart, choosenPurchaseIdFromLocation, setExtendedPurchases, pathname, navigate])
```

### 2. **Custom Hooks Closures**

#### üìç **useQueryConfig Hook**

```typescript
// src/hooks/useQueryConfig.tsx
const useQueryConfig = () => {
  const queryParams: QueryConfig = useQueryParams() // Closure: access external hook

  // Closure: access queryParams
  const queryConfig: QueryConfig = omitBy(
    {
      page: queryParams.page || '1',
      limit: queryParams.limit || '20',
      sort_by: queryParams.sort_by
      // ... other properties
    },
    isUndefined
  )

  return queryConfig // Return computed value
}
```

#### üìç **useSearchProducts Hook**

```typescript
// src/hooks/useSearchProducts.tsx
const useSearchProducts = () => {
  const [searchValue, setSearchValue] = useState('')
  const navigate = useNavigate()
  const queryConfig = useQueryConfig()

  // Closure: access navigate, queryConfig
  const onSubmitSearch = handleSubmit((data) => {
    const config = queryConfig.order
      ? omit({ ...queryConfig, name: data.name }, ['order', 'sort_by'])
      : { ...queryConfig, name: data.name }

    // Closure: access navigate
    navigate({
      pathname: path.home,
      search: createSearchParams(config).toString()
    })
  })

  return { onSubmitSearch, register }
}
```

---

## üöÄ Performance v√† Memory Management

### 1. **Memory Leaks Prevention**

#### üìç **Cleanup Functions**

```typescript
// src/App.tsx (d√≤ng 39-46)
useEffect(() => {
  // Closure: access reset function
  LocalStorageEventTarget.addEventListener('clearLS', reset)

  // Cleanup closure ƒë·ªÉ prevent memory leaks
  return () => {
    LocalStorageEventTarget.removeEventListener('clearLS', reset)
  }
}, [reset])

// src/pages/Cart/Cart.tsx (d√≤ng 142-146)
useEffect(() => {
  // Cleanup closure
  return () => {
    history.replaceState(null, '') // Clear state on unmount
  }
}, [])
```

### 2. **useCallback for Performance**

#### üìç **Stable References**

```typescript
// src/components/Header/SearchSuggestions/SearchSuggestions.tsx
const handleSelectSuggestion = useCallback(
  (suggestion: string) => {
    // Closure v·ªõi stable reference
    onSelectSuggestion(suggestion)
    onHide()
  },
  [onSelectSuggestion, onHide] // Dependencies captured
)

// Usage: Tr√°nh re-render unnecessary
<SearchSuggestionItem
  onSelect={handleSelectSuggestion} // Stable reference
/>
```

### 3. **useMemo for Expensive Calculations**

#### üìç **Optimized Computations**

```typescript
// src/pages/Cart/Cart.tsx
const isAllChecked = useMemo(
  () => extendedPurchases.every((purchase) => purchase.isChecked), // Closure: access extendedPurchases
  [extendedPurchases]
)

const checkedPurchases = useMemo(
  () => extendedPurchases.filter((purchase) => purchase.isChecked), // Closure
  [extendedPurchases]
)
```

---

## üí° Best Practices

### 1. **Currying for Event Handlers**

```typescript
// ‚úÖ Good: Currying pattern
const handleItemClick = (itemId: string) => (event: React.MouseEvent) => {
  // Handle click with itemId
}

// Usage:
{items.map(item => (
  <div key={item.id} onClick={handleItemClick(item.id)}>
    {item.name}
  </div>
))}

// ‚ùå Bad: Anonymous functions in render
{items.map(item => (
  <div key={item.id} onClick={() => handleClick(item.id)}>
    {item.name}
  </div>
))}
```

### 2. **Proper Dependency Management**

```typescript
// ‚úÖ Good: Proper dependencies
const callback = useCallback(() => {
  doSomething(value)
}, [value]) // Include all dependencies

// ‚ùå Bad: Missing dependencies
const callback = useCallback(() => {
  doSomething(value)
}, []) // Missing 'value' dependency
```

### 3. **Cleanup Closures**

```typescript
// ‚úÖ Good: Always cleanup
useEffect(() => {
  const handler = setTimeout(() => {
    // Do something
  }, 1000)

  return () => clearTimeout(handler) // Cleanup closure
}, [])

// ‚ùå Bad: No cleanup
useEffect(() => {
  setTimeout(() => {
    // Do something
  }, 1000) // Memory leak potential
}, [])
```

### 4. **Avoid Closure Pitfalls**

```typescript
// ‚ùå Stale Closure Problem
const [count, setCount] = useState(0)

useEffect(() => {
  const interval = setInterval(() => {
    setCount(count + 1) // Stale closure - count is always 0
  }, 1000)

  return () => clearInterval(interval)
}, []) // Empty dependency array

// ‚úÖ Solution 1: Proper dependencies
useEffect(() => {
  const interval = setInterval(() => {
    setCount(count + 1)
  }, 1000)

  return () => clearInterval(interval)
}, [count])

// ‚úÖ Solution 2: Functional update
useEffect(() => {
  const interval = setInterval(() => {
    setCount((prev) => prev + 1) // No stale closure
  }, 1000)

  return () => clearInterval(interval)
}, [])
```

---

## üéØ Patterns trong D·ª± √°n

### 1. **Factory Pattern v·ªõi HOF**

```typescript
// Pattern: Create specialized functions
const createEventHandler = (type: string) => (data: any) => {
  switch (type) {
    case 'click':
      return handleClick(data)
    case 'change':
      return handleChange(data)
    default:
      return handleDefault(data)
  }
}

// Usage
const clickHandler = createEventHandler('click')
const changeHandler = createEventHandler('change')
```

### 2. **Composition Pattern**

```typescript
// src/hooks/useQueryConfig.tsx
const useQueryConfig = () => {
  const queryParams = useQueryParams() // Compose with other hook

  return omitBy(
    {
      // Compose with lodash HOF
      page: queryParams.page || '1'
      // ... other properties
    },
    isUndefined
  )
}
```

### 3. **Observer Pattern v·ªõi Closures**

```typescript
// src/App.tsx
LocalStorageEventTarget.addEventListener('clearLS', reset)

// reset function maintains closure over context
const reset = () => {
  setIsAuthenticated(false)
  setExtendedPurchases([])
  setProfile(null)
}
```

---

## üéâ K·∫øt lu·∫≠n

### üìä **Higher Order Functions trong Shopee Clone:**

1. **Array Methods**: `map()`, `filter()`, `reduce()`, `slice()` - 95% components
2. **Lodash Utils**: `omit()`, `omitBy()`, `keyBy()` - Data transformation
3. **React Hooks**: `useMemo()`, `useCallback()`, `useEffect()` - Performance optimization
4. **Custom Currying**: Event handlers v·ªõi multiple parameters

### üîê **Closures Applications:**

1. **Event Handlers**: Capture scope variables for dynamic behavior
2. **React Hooks**: State v√† effect management
3. **Custom Hooks**: Encapsulate complex logic
4. **Memory Management**: Cleanup functions v√† resource management

### üí™ **Benefits Achieved:**

- ‚úÖ **Code Reusability**: HOF patterns gi·∫£m duplicate code
- ‚úÖ **Performance**: Proper memoization v·ªõi closures
- ‚úÖ **Maintainability**: Clear separation of concerns
- ‚úÖ **Type Safety**: TypeScript + HOF = Better developer experience
- ‚úÖ **Memory Safety**: Proper cleanup prevents leaks

### üöÄ **Key Takeaways:**

1. **HOF l√† foundation** c·ªßa functional programming trong React
2. **Closures enable** powerful patterns nh∆∞ currying v√† memoization
3. **Proper dependency management** critical cho performance
4. **Always cleanup** ƒë·ªÉ avoid memory leaks
5. **TypeScript enhances** HOF v√† closure safety

---

**üìù T√°c gi·∫£**: D·ª± √°n Shopee Clone TypeScript  
**üìÖ Ng√†y t·∫°o**: 2024  
**üîÑ C·∫≠p nh·∫≠t**: React 18.0+ Features v√† Modern Patterns

---

_"Higher Order Functions and Closures are not just programming concepts - they are the building blocks of elegant, maintainable, and performant React applications."_
